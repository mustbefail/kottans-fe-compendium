# Глава 1: Что такое область видимости?

# Компилируемый или интерпретируемый?

Компиляция - это набор шагов, которые обрабатывают исходный код и превращают его в исполняемый набор инструкций, которые понятны для компьютера. Чаще всего, весь код трансформируется в инструкции целиком и сразу, после чего они сохраняются отдельно для дальнейшего запуска.

Интерпретация - похожий на компилирование процесс, в плане того, что он трансформирует код в машинные инструкции, но сам процесс слегка отличается. Интерпретатор превращает строки кода в инструкции и тут же их запускает одна за одной, вместо того чтобы скомпилировать всё сразу, как это происходит при компиляции.

![](../assets/compilervsinterpreter.png)

Обычно эти два метода обработки программ являются взаимоисключающими, но современные движки JS включают в себя оба варианта в разных формах.

# Компиляция кода
Разобраться в том, является ли JS компилированным языком программирования важно, потому что обычно области видимости определяются именно на стадии компиляции.

В классическом виде, программа обрабатывается компилятором в 3 шага:
  1. **Токенизация/лексирование**: разделение строки на части, которые имеют значение (для языка программирования), которые называются токенами. Пример: программа `var a = 2;`. Эта программа была бы разбита на следующие токены: `var`, `a`, `=`, `2` и `;`. Отступы в некоторых языках тоже могут быть рассмотрены как токены.

  (Между токенизацией и лексированием есть небольшая разница, которая состоит в том, что если при токенизации токенам придётся дополнительный контекст (например, *этот* токен - строка, *вот этот* - цифра, а вон *тот* - оператор сравнения), то такой процесс называется лексированием.)

  2. **Парсинг**: построение дерева вложенных элементов из массива токенов, которое представляет из себя грамматическую структуру программы. Называется Абстрактное Синтаксическое Дерево (*Absctract Syntax Tree* (*AST*)).

  3. **Генерация кода**: на основе AST создаётся исполняемый код. Эта часть может очень сильно разниться в зависимости от платформы, языка программирования и других факторов.

  Движок JS берёт описанное дерево AST для `var a = 2;` и превращает его в набор машинных инструкций чтобы *создать* переменную под названием `a` (включая занятие памяти и т.д.), а потом записать значение в `a`.

Движок JS гораздо сложнее, чем только эти 3 шага. В процессе парсинга и генерации кода есть промежуточные шаги для оптимизации производительности выполнения кода (например, удаление ненужных элементов). Код даже может быть перекомпилирован или переоптимизирован прямо в процессе выполнения.

## Главное: две фазы
Самое главное наблюдение, которое мы можем сделать над обработкой JS программ - это то, что оно происходит (как минимум) в две фазы: парсинг/компиляция сначала, а потом выполнение.

Тот факт, что сначала происходит парсинг/компиляция легко проверить, вот некоторые примеры:

### Синтаксические ошибки с самого начала
Пример:

```js
  var greeting = "Hello";

  console.log(greeting);

  greeting = ."Hi";
  // SyntaxError: unexpected token .
```

Эта программа вызывает ошибку `SyntaxError`. В коде эта ошибка находится после вполне нормального `console.log()`, но `"Hello"` не будет выведено в консоль. Единственный способ для движка JS узнать о том, что в коде есть ошибка до того как выполнение дойдёт до неё - это пропарсить код перед его выполнением.

### Ранние ошибки
Другой пример:

```js
  console.log("Howdy");

  saySomething("Hello","Hi");
  // Uncaught SyntaxError: Duplicate parameter name not
  // allowed in this context

  function saySomething(greeting,greeting) {
      "use strict";
      console.log(greeting);
  }
```

Слово `"Howdy"`, как и в предыдущем примере, не будет выведено в консоль. Движок JS полностью парсит весь код перед тем как его выполнить иначе, он бы не знал что в функция `saySomething()` ждёт два аргумента с одинаковым названием, что запрещено при использовании "строгого режима". Это так же подтверждает, что движок заглянул внутрь функции, т.к. именно там находится объявление "строгого режима".

### Всплытие
Последний пример:
```js
  function saySomething() {
      var greeting = "Hello";
      {
          greeting = "Howdy";  // error comes from here
          let greeting = "Hi";
          console.log(greeting);
      }
  }

  saySomething();
  // ReferenceError: Cannot access 'greeting' before
  // initialization
```
Ошибка `ReferenceError` появляется на строке `greeting = "Howdy"`. Однако у нас уже есть переменная `greeting` внутри функции `saySomething`. Дело в том, что парсер уже прошёлся по коду и увидел, что в блоке, в котором находится присвоение значения `"Howdy"` находится объявление локальной переменной `let greeting = "Hi";`. Но т.к. мы не можем обращаться к переменным, объявленным при помощи `let` или `const` до их непосредственного объявления, происходит ошибка. Опять таки, если бы код просто выполнялся построчно, программа бы просто записала новое значение в переменную `greeting` в теле функции `saySomething`, и не знала бы о том, что в блоке дальше по коду будет ещё одна такая же по названию переменная.

Есть очень много нюансов в том **как именно** работает движок JS, но в конечном итоге нужно понять что он гораздо более **похож** на компилирование, чем **не похож**.

